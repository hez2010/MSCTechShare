# unsafe
只需要给想要用指针的地方套上一个 unsafe，就能随心所欲地用指针。编译时需要用 -unsafe 才能编译通过。

```cs
unsafe 
{
    int *p;
    //do something.....
}
```

#### fixed
1、fixed 语句禁止垃圾回收器重定位可移动的变量。fixed 语句只能出现在不安全的上下文中。Fixed 还可用于创建固定大小的缓冲区。    
2、fixed 语句设置指向托管变量的指针并在 statement 执行期间“钉住”该变量。如果没有 fixed 语句，则指向可移动托管变量的指针的作用很小，因为垃圾回收可能不可预知地重定位变量。C# 编译器只允许在 fixed 语句中分配指向托管变量的指针。  
3、执行完语句中的代码后，任何固定变量都被解除固定并受垃圾回收的制约。因此，不要指向 fixed 语句之外的那些变量。  

当进程初始化时，CLR保留一块连续的地址空间，这个地址空间最初并没有对应的物理存储空间，这个地址空间就是托管堆。在托管堆中，连续分配的对象可以确保他们在内存中时连续的。托管堆维护着一个叫做NextObjPtr的指针，它指向下一个对象在堆中的分配位置。调用new操作符创建对象时，如果没有足够的地址空间来分配对象，也即对象的字节数+NextObjPtr指针的地址超过了地址空间末尾则需要进行一次垃圾回收。  
回收机制是采用根标记堆上的对象，当根不可达时则回收堆所占的内存（这里不去扩展，只给个大概的脉络，其实还涉及GC的代Generation），当回收完毕时的下一阶段就是压缩内存，这个阶段垃圾回收器线性的便利堆，以寻找未标记（垃圾）对象的连续内存块，如果发现的内存块比较小，垃圾回收期会忽略它们，但是，如果发现大的，可用的连续内存块，垃圾回收器会把非垃圾的对象移动到这里以压缩堆。  
很自然地，移动内存中的对象之后，包含“指向这些对象的指针”的变量和CPU寄存器现在都会变得无效。所以垃圾回收器必须重新访问应用程序的所有根，并修改它们来指向对象的新内存位置。另外，如果对象中的字段指向的是另一个已移动了位置的对象，垃圾回收器要负责更正这些字段。堆内存压缩之后，托管堆的NextObjPtr指针指向紧接在最后一个非垃圾对象之后的对象之后的位置。  
上面所说的都是在托管环境的CLR指导下完成的，那如果是非安全代码如果是指针呢？指针指向了一个托管对象，而GC时内存会压缩，谁还管你的非安全指针，我们CLR只负责托管代码啊！所以微软给出的解决办法是采用fixed关键字。  

```cs
static unsafe void ArrPrint()
{
    const int aL = 10;
    //声明一个字节数组用于固定
    Byte[] ints = new Byte[aL];
    //创建大量对象
    for (int i = 0; i < 10000000; i++) new Object();

    //执行完 fixed 语句中的代码后，任何固定变量都被解除固定并受 GC 制约
    //如果没有这句话 ip 指向的地址可能会改变，因为 ints 是托管的
    fixed (Byte* ip = ints)
    {
        for (int i = 0; i < aL; i++)
        {
            //采用指针更改数组值
            ip[i] = (byte)new Random(Guid.NewGuid().GetHashCode()).Next(0,256);
        }
    }
    //强制回收垃圾
    GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced);
    Array.ForEach(ints, _ => Console.WriteLine(_));
}
```

如果还能输出结果说明指针操作成功，没有因为GC的回收造成指针操纵了不正确的地址，因为fixed语句块钉住了ints变量，禁止垃圾回收器操作内存地址，重定位可移动变量。为什么要这样做呢？我们不是可以用托管代码直接操作数组吗？  
因为指针操作数组是很快的，因为它会关闭数组索引的检查即关闭索引的上下限检查，如果极其要求性能的话推荐这么做。
